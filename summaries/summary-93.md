## ECMAScript仕様輪読会 第93回 議事録

このドキュメントは、ECMAScript仕様のTemporal API周辺、特にタイムゾーンと日付・時刻を扱う抽象操作（Abstract Operation）に関する輪読会の議論をまとめたものです。

### 1. 前回の振り返り

本編に入る前に、前回議論した内容について振り返りが行われました。

*   **`NamedTimeZoneOffsetNanoseconds` の実装依存性**:
    *   タイムゾーンのサポートは実装に依存するため。
    *   夏時間（Daylight Saving Time）の切り替えにより、特定の壁時計時刻（Wall-Clock Time）が複数存在したり、逆に存在しなかったりするケースがあるため。
*   **タイムゾーン識別子**:
    *   `TimeZoneIdentifier` レコードは `Identifier` と `PrimaryIdentifier` の2つのフィールドを持つ。
    *   `Identifier` はIANAタイムゾーンデータベースのリンク名（エイリアス）である場合がある。
    *   `SystemTimeZoneIdentifier` はホスト環境のタイムゾーン名を返し、オフセットではなく`"America/New_York"`のようなIANA名で返すことが推奨される。
*   **`LocalTime(t)`**:
    *   UTC時刻 `t` を受け取り、システムのタイムゾーンに基づいてローカル時刻に変換する操作。

### 2. `UTC(t)` 抽象操作の読解

今回は `LocalTime` の逆操作である `UTC(t)` から読み進めました。この操作はローカル時刻 `t` をUTC時刻に変換します。

#### 2.1. 操作の概要と複雑性

この操作の主な目的は、ローカル時刻をUTCのタイムスタンプ（Time Value）に変換することです。
複雑性の中心は、夏時間の切り替えなどによって発生する時刻の**重複**と**欠落**の扱いです。

*   **時刻の重複（Negative Time Zone Transition）**:
    *   夏時間が終了する際など、オフセットが減少すると同じ時刻が2回発生します。（例: 午前2時が2回くる）
    *   この場合、仕様では**移行前のタイムゾーンで解釈する**と定められています。アルゴリズム上は、候補となる2つの時刻のうち、最初のもの（インデックス `[0]`）を選択することでこれを実現しています。

*   **時刻の欠落（Positive Time Zone Transition）**:
    *   夏時間が開始する際など、オフセットが増加すると特定の時刻が存在しなくなります。（例: 午前2時台が飛ぶ）
    *   この場合、仕様では**移行前のタイムゾーンで解釈する**と定められています。アルゴリズム上は、欠落した時刻 `t` の直前の有効な時刻 `tBefore` を見つけ、その時刻を基準にオフセットを計算します。

#### 2.2. ノートでの具体例

仕様のノートでは、これらの複雑なケースについて具体的な例が挙げられていました。

*   **重複の例**: `2017-11-05 01:30:00` in `America/New_York`
    *   この時刻は2回発生しますが、夏時間中である `UTC-04` として解釈されなければならない、とされています。（移行後の `UTC-05` ではない）

*   **欠落の例**: `2017-03-12 02:30:00` in `America/New_York`
    *   この時刻は存在しませんが、`UTC-05` の `02:30` （`UTC-04` の `03:30` と同義）として解釈されなければならない、とされています。これは移行前のタイムゾーンオフセットを適用した結果です。

#### 2.3. 変換の非可逆性

`LocalTime(UTC(tLocal))` が必ずしも元の `tLocal` と等しくならない、という往復変換の非可逆性についても言及されました。これは、時刻の重複・欠落があるためです。

### 3. 日付・時刻を構成する抽象操作

続いて、日付と時刻の各要素（年、月、日、時、分、秒など）から最終的なタイムスタンプを組み立てるための一連の抽象操作を読み進めました。

#### 3.1. `MakeTime(hour, min, sec, ms)`

*   **目的**: 時・分・秒・ミリ秒から、その日の0時からの経過ミリ秒数を計算する。
*   **注意点**: 計算は浮動小数点数で行われ、結合法則が成り立たないため、仕様書に記載された通りの順序で計算を実行する必要があります。
    ```
    // (h * msPerHour + m * msPerMinute) + (s * msPerSecond + ms) のような順番で計算
    (h * 3600000 + m * 60000) + (s * 1000 + ms)
    ```

#### 3.2. `MakeDay(year, month, day)`

*   **目的**: 年・月・日から、エポック（1970-01-01T00:00:00Z）からの経過日数を計算する。
*   **アルゴリズムの要点**:
    1.  **月の正規化**: `13月` は翌年の `1月` のように、年と月に変換されます。
    2.  **基準日の計算**: 正規化された年・月における**1日**のタイムスタンプ `t` を求めます。
    3.  **最終的な日数の計算**: `Day(t) + day - 1` という計算で最終的な経過日数を算出します。
        *   ここで `day` を直接使わず、一度「1日」のタイムスタンプを求めてから `day - 1` を加算するのは、`day` に `32` などの不正な値が渡される可能性があるため、まず有効な日付（その月の1日）を基準として計算を安全に行うための設計であると考察されました。

#### 3.3. `MakeDate(day, time)`

*   **目的**: `MakeDay` で得られた経過日数と `MakeTime` で得られたミリ秒を結合し、エポックからの総ミリ秒数を算出する。非常にシンプルな結合操作です。

#### 3.4. `MakeFullYear(year)`

*   **目的**: 与えられた年を完全な4桁の年に変換する。
*   **驚きの仕様**: この操作は、`year` が `0` から `99` の範囲で与えられた場合、**1900年台の年**として解釈します。
    *   `MakeFullYear(26)` は `1926` を返します。
    *   `MakeFullYear(0)` は `1900` を返します。
    *   `100` 以上の場合は、その値がそのまま返されます。
*   **背景**: これは `new Date()` コンストラクタの歴史的な挙動との互換性を保つための仕様です。輪読会では実際にJavaScriptでこの挙動が確認されました。

    ```javascript
    // 輪読会で実行されたコード例
    new Date(26, 1, 1); // -> Tue Feb 01 1926 00:00:00 GMT+0900 (日本標準時)
    new Date(0, 1, 1);  // -> Tue Feb 01 1900 00:00:00 GMT+0900 (日本標準時)
    ```
    この「JavaScriptの闇」とも言える仕様に、参加者からは驚きの声が上がりました。

#### 3.5. `TimeClip(time)`

*   **目的**: 与えられたタイムスタンプが、ECMAScriptで表現可能な `TimeValue` の範囲内（`±8.64e15` ミリ秒）に収まるようにクリップ（切り捨て）する。
*   範囲外の値が与えられた場合は `NaN` を返します。これにより、タイムスタンプが常に有効な範囲内に収まることを保証します。

### 4. 次回予告

次回は `DateTime String Format` から読み進める予定です。
