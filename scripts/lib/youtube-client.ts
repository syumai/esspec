import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';
import { createWriteStream } from 'node:fs';

const CAPTION_FORMAT = 'srt' as const;
const PREFERRED_CAPTION_LANGUAGE = 'ja';

export interface CaptionTrack {
  id: string;
  language: string;
  name: string;
  isAutoGenerated: boolean;
}

export interface LiveBroadcastConfig {
  title: string;
  description: string;
  scheduledStartTime: string; // ISO 8601 format
  privacyStatus: 'public' | 'private' | 'unlisted';
  latencyPreference: 'normal' | 'low' | 'ultraLow';
  categoryId?: number;
}

export interface LiveStreamConfig {
  title: string;
  ingestionType: 'rtmp' | 'dash' | 'hls';
  resolution: 'variable' | '240p' | '360p' | '480p' | '720p' | '1080p' | '1440p' | '2160p';
  frameRate: 'variable' | '30fps' | '60fps';
}

export interface CreatedBroadcast {
  broadcastId: string;
  streamId: string;
  youtubeUrl: string;
  streamKey?: string;
  ingestionAddress?: string;
}

export class YouTubeClient {
  private youtube;

  constructor(authClient: OAuth2Client) {
    this.youtube = google.youtube({
      version: 'v3',
      auth: authClient,
    });
  }

  /**
   * Get available caption tracks for a video
   */
  async getCaptionTracks(videoId: string): Promise<CaptionTrack[]> {
    try {
      console.log(`[INFO] Fetching caption tracks for video: ${videoId}`);

      const response = await this.youtube.captions.list({
        part: ['snippet'],
        videoId: videoId,
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new Error('No captions available for this video');
      }

      const tracks: CaptionTrack[] = response.data.items.map((item) => ({
        id: item.id!,
        language: item.snippet!.language!,
        name: item.snippet!.name!,
        isAutoGenerated: item.snippet!.trackKind === 'ASR',
      }));

      console.log(`[INFO] Found ${tracks.length} caption track(s):`);
      tracks.forEach((track) => {
        const type = track.isAutoGenerated ? '(auto-generated)' : '(manual)';
        console.log(`  - ${track.language}: ${track.name} ${type}`);
      });

      return tracks;
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('YouTube Data API quota exceeded. Please try again later or request a quota increase.');
      } else if (error.code === 404) {
        throw new Error(`Video not found: ${videoId}`);
      } else {
        throw new Error(`Failed to fetch caption tracks: ${error.message}`);
      }
    }
  }

  /**
   * Download a caption track to a file
   */
  async downloadCaption(captionId: string, outputPath: string): Promise<void> {
    try {
      console.log(`[INFO] Downloading caption track: ${captionId}`);

      const response = await this.youtube.captions.download(
        {
          id: captionId,
          tfmt: CAPTION_FORMAT,
        },
        {
          responseType: 'stream',
        }
      );

      return new Promise((resolve, reject) => {
        const writer = createWriteStream(outputPath);

        (response.data as any)
          .pipe(writer)
          .on('finish', () => {
            console.log(`[SUCCESS] Caption downloaded to: ${outputPath}`);
            resolve();
          })
          .on('error', (error: Error) => {
            reject(new Error(`Failed to write caption file: ${error.message}`));
          });
      });
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('Permission denied. Make sure your OAuth credentials have the correct scopes.');
      } else if (error.code === 404) {
        throw new Error(`Caption track not found: ${captionId}`);
      } else {
        throw new Error(`Failed to download caption: ${error.message}`);
      }
    }
  }

  /**
   * Get the best available Japanese caption track
   * Prefers manual captions over auto-generated ones
   */
  selectJapaneseCaptionTrack(tracks: CaptionTrack[]): CaptionTrack | null {
    // Filter Japanese tracks
    const japaneseTracks = tracks.filter((track) => track.language === PREFERRED_CAPTION_LANGUAGE);

    if (japaneseTracks.length === 0) {
      return null;
    }

    // Prefer manual captions over auto-generated
    const manualTrack = japaneseTracks.find((track) => !track.isAutoGenerated);
    if (manualTrack) {
      console.log('[INFO] Using manual Japanese caption track');
      return manualTrack;
    }

    // Fall back to auto-generated
    console.log('[WARN] Using auto-generated Japanese caption track (manual captions not available)');
    return japaneseTracks[0];
  }

  /**
   * Create a live broadcast
   */
  async createLiveBroadcast(config: LiveBroadcastConfig): Promise<string> {
    try {
      console.log(`[INFO] Creating live broadcast: ${config.title}`);

      const response = await this.youtube.liveBroadcasts.insert({
        part: ['snippet', 'status', 'contentDetails'],
        requestBody: {
          snippet: {
            title: config.title,
            description: config.description,
            scheduledStartTime: config.scheduledStartTime,
            ...(config.categoryId !== undefined && { categoryId: String(config.categoryId) }),
          },
          status: {
            privacyStatus: config.privacyStatus,
            selfDeclaredMadeForKids: false,
          },
          contentDetails: {
            latencyPreference: config.latencyPreference,
            enableAutoStart: false,
            enableAutoStop: false,
            enableDvr: true,
            recordFromStart: true,
            enableClosedCaptions: true,
          },
        },
      });

      const broadcastId = response.data.id!;
      console.log(`[SUCCESS] Broadcast created with ID: ${broadcastId}`);

      return broadcastId;
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('YouTube Data API quota exceeded. Please try again tomorrow or request a quota increase at https://console.cloud.google.com/apis/api/youtube.googleapis.com/quotas');
      } else if (error.code === 400) {
        throw new Error(`Invalid broadcast parameters: ${error.message}`);
      } else if (error.code === 401) {
        throw new Error('Authentication failed. Please run: pnpm run auth');
      } else {
        throw new Error(`Failed to create broadcast: ${error.message}`);
      }
    }
  }

  /**
   * Create a live stream
   */
  async createLiveStream(config: LiveStreamConfig): Promise<{ streamId: string; ingestionInfo: any }> {
    try {
      console.log(`[INFO] Creating live stream: ${config.title}`);

      const response = await this.youtube.liveStreams.insert({
        part: ['snippet', 'cdn', 'contentDetails'],
        requestBody: {
          snippet: {
            title: config.title,
          },
          cdn: {
            ingestionType: config.ingestionType,
            resolution: config.resolution,
            frameRate: config.frameRate,
          },
          contentDetails: {
            isReusable: false,
          },
        },
      });

      const streamId = response.data.id!;
      const ingestionInfo = response.data.cdn?.ingestionInfo;

      console.log(`[SUCCESS] Stream created with ID: ${streamId}`);

      return { streamId, ingestionInfo };
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('YouTube Data API quota exceeded. Please try again tomorrow or request a quota increase.');
      } else if (error.code === 400) {
        throw new Error(`Invalid stream parameters: ${error.message}`);
      } else {
        throw new Error(`Failed to create stream: ${error.message}`);
      }
    }
  }

  /**
   * Update an existing live broadcast
   */
  async updateLiveBroadcast(broadcastId: string, config: Partial<LiveBroadcastConfig>): Promise<void> {
    try {
      console.log(`[INFO] Updating live broadcast: ${broadcastId}`);

      // First, get the current broadcast to preserve existing settings
      const currentResponse = await this.youtube.liveBroadcasts.list({
        part: ['snippet', 'status', 'contentDetails'],
        id: [broadcastId],
      });

      if (!currentResponse.data.items || currentResponse.data.items.length === 0) {
        throw new Error(`Broadcast not found: ${broadcastId}`);
      }

      const currentBroadcast = currentResponse.data.items[0];
      const currentSnippet = currentBroadcast.snippet!;
      const currentStatus = currentBroadcast.status!;
      const currentContentDetails = currentBroadcast.contentDetails!;

      // Build updated snippet
      const updatedSnippet: any = {
        title: config.title ?? currentSnippet.title,
        description: config.description ?? currentSnippet.description,
        scheduledStartTime: config.scheduledStartTime ?? currentSnippet.scheduledStartTime,
      };

      // Add categoryId if provided
      if (config.categoryId !== undefined) {
        updatedSnippet.categoryId = String(config.categoryId);
      } else if ((currentSnippet as any).categoryId) {
        updatedSnippet.categoryId = (currentSnippet as any).categoryId;
      }

      // Update the broadcast
      await this.youtube.liveBroadcasts.update({
        part: ['snippet', 'status', 'contentDetails'],
        requestBody: {
          id: broadcastId,
          snippet: updatedSnippet,
          status: {
            privacyStatus: config.privacyStatus ?? currentStatus.privacyStatus,
            selfDeclaredMadeForKids: currentStatus.selfDeclaredMadeForKids ?? false,
          },
          contentDetails: {
            latencyPreference: config.latencyPreference ?? currentContentDetails.latencyPreference,
            enableAutoStart: currentContentDetails.enableAutoStart ?? false,
            enableAutoStop: currentContentDetails.enableAutoStop ?? false,
            enableDvr: currentContentDetails.enableDvr ?? true,
            recordFromStart: currentContentDetails.recordFromStart ?? true,
            enableClosedCaptions: currentContentDetails.enableClosedCaptions ?? true,
          },
        },
      });

      console.log(`[SUCCESS] Broadcast updated: ${broadcastId}`);
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('YouTube Data API quota exceeded. Please try again tomorrow or request a quota increase at https://console.cloud.google.com/apis/api/youtube.googleapis.com/quotas');
      } else if (error.code === 404) {
        throw new Error(`Broadcast not found: ${broadcastId}`);
      } else if (error.code === 400) {
        throw new Error(`Invalid broadcast parameters: ${error.message}`);
      } else if (error.code === 401) {
        throw new Error('Authentication failed. Please run: pnpm run auth');
      } else {
        throw new Error(`Failed to update broadcast: ${error.message}`);
      }
    }
  }

  /**
   * Bind a live stream to a broadcast
   */
  async bindBroadcastToStream(broadcastId: string, streamId: string): Promise<void> {
    try {
      console.log(`[INFO] Binding stream ${streamId} to broadcast ${broadcastId}`);

      await this.youtube.liveBroadcasts.bind({
        part: ['id', 'contentDetails'],
        id: broadcastId,
        streamId: streamId,
      });

      console.log('[SUCCESS] Stream bound to broadcast');
    } catch (error: any) {
      if (error.code === 404) {
        throw new Error(`Broadcast or stream not found. Broadcast ID: ${broadcastId}, Stream ID: ${streamId}`);
      } else if (error.code === 400) {
        throw new Error(`Failed to bind stream: ${error.message}`);
      } else {
        throw new Error(`Failed to bind stream to broadcast: ${error.message}`);
      }
    }
  }

  /**
   * Create a complete live broadcast with stream
   * Orchestrates the full workflow: create broadcast, create stream, bind them together
   */
  async createCompleteBroadcast(
    broadcastConfig: LiveBroadcastConfig,
    streamConfig: LiveStreamConfig
  ): Promise<CreatedBroadcast> {
    let broadcastId: string | undefined;
    let streamId: string | undefined;

    try {
      // Step 1: Create broadcast
      broadcastId = await this.createLiveBroadcast(broadcastConfig);

      // Step 2: Create stream
      const { streamId: createdStreamId, ingestionInfo } = await this.createLiveStream(streamConfig);
      streamId = createdStreamId;

      // Step 3: Bind broadcast to stream
      await this.bindBroadcastToStream(broadcastId, streamId);

      // Step 4: Generate YouTube URL
      const youtubeUrl = `https://www.youtube.com/live/${broadcastId}`;

      console.log('[SUCCESS] Complete broadcast setup finished');

      return {
        broadcastId,
        streamId,
        youtubeUrl,
        streamKey: ingestionInfo?.streamName,
        ingestionAddress: ingestionInfo?.ingestionAddress,
      };
    } catch (error) {
      // Log created resources for manual cleanup
      if (broadcastId || streamId) {
        console.error('[ERROR] Partial failure occurred. Created resources:');
        if (broadcastId) {
          console.error(`  Broadcast ID: ${broadcastId}`);
        }
        if (streamId) {
          console.error(`  Stream ID: ${streamId}`);
        }
        console.error('  You may need to manually delete these resources from YouTube Studio.');
      }
      throw error;
    }
  }
}
