import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';
import { createWriteStream } from 'node:fs';

const CAPTION_FORMAT = 'srt' as const;
const PREFERRED_CAPTION_LANGUAGE = 'ja';

export interface CaptionTrack {
  id: string;
  language: string;
  name: string;
  isAutoGenerated: boolean;
}

export class YouTubeClient {
  private youtube;

  constructor(authClient: OAuth2Client) {
    this.youtube = google.youtube({
      version: 'v3',
      auth: authClient,
    });
  }

  /**
   * Get available caption tracks for a video
   */
  async getCaptionTracks(videoId: string): Promise<CaptionTrack[]> {
    try {
      console.log(`[INFO] Fetching caption tracks for video: ${videoId}`);

      const response = await this.youtube.captions.list({
        part: ['snippet'],
        videoId: videoId,
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new Error('No captions available for this video');
      }

      const tracks: CaptionTrack[] = response.data.items.map((item) => ({
        id: item.id!,
        language: item.snippet!.language!,
        name: item.snippet!.name!,
        isAutoGenerated: item.snippet!.trackKind === 'ASR',
      }));

      console.log(`[INFO] Found ${tracks.length} caption track(s):`);
      tracks.forEach((track) => {
        const type = track.isAutoGenerated ? '(auto-generated)' : '(manual)';
        console.log(`  - ${track.language}: ${track.name} ${type}`);
      });

      return tracks;
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('YouTube Data API quota exceeded. Please try again later or request a quota increase.');
      } else if (error.code === 404) {
        throw new Error(`Video not found: ${videoId}`);
      } else {
        throw new Error(`Failed to fetch caption tracks: ${error.message}`);
      }
    }
  }

  /**
   * Download a caption track to a file
   */
  async downloadCaption(captionId: string, outputPath: string): Promise<void> {
    try {
      console.log(`[INFO] Downloading caption track: ${captionId}`);

      const response = await this.youtube.captions.download(
        {
          id: captionId,
          tfmt: CAPTION_FORMAT,
        },
        {
          responseType: 'stream',
        }
      );

      return new Promise((resolve, reject) => {
        const writer = createWriteStream(outputPath);

        (response.data as any)
          .pipe(writer)
          .on('finish', () => {
            console.log(`[SUCCESS] Caption downloaded to: ${outputPath}`);
            resolve();
          })
          .on('error', (error: Error) => {
            reject(new Error(`Failed to write caption file: ${error.message}`));
          });
      });
    } catch (error: any) {
      if (error.code === 403) {
        throw new Error('Permission denied. Make sure your OAuth credentials have the correct scopes.');
      } else if (error.code === 404) {
        throw new Error(`Caption track not found: ${captionId}`);
      } else {
        throw new Error(`Failed to download caption: ${error.message}`);
      }
    }
  }

  /**
   * Get the best available Japanese caption track
   * Prefers manual captions over auto-generated ones
   */
  selectJapaneseCaptionTrack(tracks: CaptionTrack[]): CaptionTrack | null {
    // Filter Japanese tracks
    const japaneseTracks = tracks.filter((track) => track.language === PREFERRED_CAPTION_LANGUAGE);

    if (japaneseTracks.length === 0) {
      return null;
    }

    // Prefer manual captions over auto-generated
    const manualTrack = japaneseTracks.find((track) => !track.isAutoGenerated);
    if (manualTrack) {
      console.log('[INFO] Using manual Japanese caption track');
      return manualTrack;
    }

    // Fall back to auto-generated
    console.log('[WARN] Using auto-generated Japanese caption track (manual captions not available)');
    return japaneseTracks[0];
  }
}
